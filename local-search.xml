<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>[技术笔记]一些常用库的引入规定（持续更新）</title>
    <link href="/2020/08/13/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0-%E4%B8%80%E4%BA%9B%E5%B8%B8%E7%94%A8%E5%BA%93%E7%9A%84%E5%BC%95%E5%85%A5%E8%A7%84%E5%AE%9A%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89/"/>
    <url>/2020/08/13/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0-%E4%B8%80%E4%BA%9B%E5%B8%B8%E7%94%A8%E5%BA%93%E7%9A%84%E5%BC%95%E5%85%A5%E8%A7%84%E5%AE%9A%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<pre><code>import pandas as pdfrom pandas import Series, DataFrameimport matplotlib.pyplot as plt # 常用的绘图库from datetime import datetime/date/time/timedelta # python标准库里常用的时间方法from dateutil.parser import prase # pandas自动安装的时间包，parse方法可以解析几乎所有人类能够理解的日期表达形式</code></pre>]]></content>
    
    
    <categories>
      
      <category>技术笔记</category>
      
      <category>python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>常用库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[技术笔记]plt.plot()的marker、color、linestyle参数</title>
    <link href="/2020/08/04/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0-plt-plot-%E7%9A%84marker%E3%80%81color%E3%80%81linestyle%E5%8F%82%E6%95%B0/"/>
    <url>/2020/08/04/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0-plt-plot-%E7%9A%84marker%E3%80%81color%E3%80%81linestyle%E5%8F%82%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<p><em>ax.plot(x, y, ‘g—‘)</em>和<em>ax.plot(x, y, linestyle=’—‘, color=’g’)</em>是等价的，前者通过格式字符串书写，较为简单，其格式可以为：</p><pre><code>fmt = &#39;[marker][line][color]&#39;</code></pre><p>或者：</p><pre><code>fmt = &#39;[color][marker][line]&#39;</code></pre><p>当然也可以通过color(c) = …, linestyle(ls) = …, marker = …获得。三者的具体常用标记如下：</p><h3 id="Colors"><a href="#Colors" class="headerlink" title="Colors"></a>Colors</h3><div class="table-container"><table><thead><tr><th>character</th><th>color</th></tr></thead><tbody><tr><td>‘b’</td><td>blue</td></tr><tr><td>‘g’</td><td>green</td></tr><tr><td>‘r’</td><td>red</td></tr><tr><td>‘c’</td><td>青色</td></tr><tr><td>‘m’</td><td>品红</td></tr><tr><td>‘y’</td><td>yellow</td></tr><tr><td>‘k’</td><td>black</td></tr><tr><td>‘w’</td><td>white</td></tr></tbody></table></div><p>如果颜色是格式字符串的唯一部分，则可以另外使用任何<a href="https://matplotlib.org/api/colors_api.html#module-matplotlib.colors" target="_blank" rel="noopener">matplotlib.colors</a>规格，例如全名（’green’）或十六进制字符串（’#008000’）。</p><h3 id="Markers"><a href="#Markers" class="headerlink" title="Markers"></a>Markers</h3><div class="table-container"><table><thead><tr><th>character</th><th>marker</th></tr></thead><tbody><tr><td>‘.’</td><td>点标记</td></tr><tr><td>‘,’</td><td>像素标记</td></tr><tr><td>‘o’</td><td>圆圈标记</td></tr><tr><td>‘v’</td><td>triangle_down标记</td></tr><tr><td>‘^’</td><td>三角形标记</td></tr><tr><td>‘&lt;’</td><td>triangle_left标记</td></tr><tr><td>‘&gt;’</td><td>triangle_right标记</td></tr><tr><td>‘1’</td><td>tri_down标记</td></tr><tr><td>‘2’</td><td>tri_up标记</td></tr><tr><td>‘3’</td><td>tri_left标记</td></tr><tr><td>‘4’</td><td>tri_right标记</td></tr><tr><td>‘s’</td><td>方形标记</td></tr><tr><td>‘p’</td><td>五边形标记</td></tr><tr><td>‘*’</td><td>星标</td></tr><tr><td>‘h’</td><td>六角形标记1</td></tr><tr><td>‘H’</td><td>六角形标记2</td></tr><tr><td>‘+’</td><td>加号</td></tr><tr><td>‘x’</td><td>X标记</td></tr><tr><td>‘D’</td><td>钻石标记</td></tr><tr><td>‘d’</td><td>小钻石标记</td></tr><tr><td>‘_’</td><td>水平线标记</td></tr></tbody></table></div><h3 id="Linestyles"><a href="#Linestyles" class="headerlink" title="Linestyles"></a>Linestyles</h3><div class="table-container"><table><thead><tr><th>character</th><th>linestyle</th></tr></thead><tbody><tr><td>‘-‘</td><td>实线</td></tr><tr><td>‘—‘</td><td>虚线</td></tr><tr><td>‘-.’</td><td>点划线</td></tr><tr><td>‘:’</td><td>点线</td></tr></tbody></table></div>]]></content>
    
    
    <categories>
      
      <category>技术笔记</category>
      
      <category>python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>matplotlib</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[技术笔记]Jupyter Notebook 和绘图有关的几个魔术指令（%matplotlib inline, auto, notebook）</title>
    <link href="/2020/08/02/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0-Jupyter-Notebook-%E5%92%8C%E7%BB%98%E5%9B%BE%E6%9C%89%E5%85%B3%E7%9A%84%E5%87%A0%E4%B8%AA%E9%AD%94%E6%9C%AF%E6%8C%87%E4%BB%A4%EF%BC%88-matplotlib-inline-auto-notebook%EF%BC%89/"/>
    <url>/2020/08/02/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0-Jupyter-Notebook-%E5%92%8C%E7%BB%98%E5%9B%BE%E6%9C%89%E5%85%B3%E7%9A%84%E5%87%A0%E4%B8%AA%E9%AD%94%E6%9C%AF%E6%8C%87%E4%BB%A4%EF%BC%88-matplotlib-inline-auto-notebook%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>Jupyter notebook默认输出的图片是静态的，无法进行放大等操作，可以添加一条魔术指令：</p><pre><code>%matplotlib notebook</code></pre><p>这样就能够在notebook中进行放大缩小等交互操作了。</p><p>在notebook中使用plt绘图共有三种模式：</p><ol><li>%matplotlib inline：这是默认的模式，输出的图片是静态的</li><li>%matplotlib auto：在这个模式下会弹出一个单独 的绘图窗口，和在pycharm中一样</li><li>%matplotlib notebook：在这个模式下会在notebook中产生一个绘图窗口，能够对图片进行放大缩小等操作。</li></ol><p>注：本文为转载，原文链接：<a href="https://blog.csdn.net/qq_26822029/article/details/103064856" target="_blank" rel="noopener">https://blog.csdn.net/qq_26822029/article/details/103064856</a></p>]]></content>
    
    
    <categories>
      
      <category>技术笔记</category>
      
      <category>python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Jupyter Notebook</tag>
      
      <tag>转载</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[技术笔记]pandas中常用的汇总和统计方法</title>
    <link href="/2020/07/30/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0-pandas%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84%E6%B1%87%E6%80%BB%E5%92%8C%E7%BB%9F%E8%AE%A1%E6%96%B9%E6%B3%95/"/>
    <url>/2020/07/30/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0-pandas%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84%E6%B1%87%E6%80%BB%E5%92%8C%E7%BB%9F%E8%AE%A1%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<div class="table-container"><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>count</td><td>计算非NA值的数量</td></tr><tr><td>describe</td><td>汇总统计</td></tr><tr><td>min、max</td><td>计算最大最小值</td></tr><tr><td>argmin、argmax</td><td>最大最小值所在的索引位置（整数）</td></tr><tr><td>idxmin、idxmax</td><td>最大最小值所在的索引标签</td></tr><tr><td>quantile</td><td>计算样本的分位数</td></tr><tr><td>sum</td><td>值的总和</td></tr><tr><td>mean</td><td>值的平均数</td></tr><tr><td>median</td><td>值的算术中位数</td></tr><tr><td>mad</td><td>平均绝对离差</td></tr><tr><td>var</td><td>方差</td></tr><tr><td>std</td><td>标准差</td></tr><tr><td>skew</td><td>偏度</td></tr><tr><td>kurt</td><td>峰度</td></tr><tr><td>cumsum</td><td>累计和</td></tr><tr><td>cummin、cummax</td><td>累计最大值和累计最小值</td></tr><tr><td>cumprod</td><td>累计积</td></tr><tr><td>diff</td><td>一阶差分</td></tr><tr><td>pct_change</td><td>百分数变化</td></tr></tbody></table></div><p><sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="上述统计方法都是基于样本而言，自由度为N-1">[1]</span></a></sup></p><p>注释：</p><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>上述统计方法都是基于样本而言，自由度为N-1<a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>技术笔记</category>
      
      <category>python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>统计</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[技术笔记]dataframe.apply和groupby.apply的区别</title>
    <link href="/2020/07/28/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0-dataframe-apply%E5%92%8Cgroupby-apply%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <url>/2020/07/28/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0-dataframe-apply%E5%92%8Cgroupby-apply%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<p>在看书学习apply函数的过程中，我发现书上还是比较集中于讲解apply在groupby分组、聚合这方面的作用，如下面这个用特定于分组的值填充缺失值<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="参考了书上代码">[1]</span></a></sup>：<br>    In [91]: s = pd.Series(np.random.randn(6))</p><pre><code>In [92]: s[::2] = np.nanIn [93]: sOut[93]: 0         NaN1   -0.1259212         NaN3   -0.8844754         NaN5    0.227290dtype: float64In [94]: s.fillna(s.mean())Out[94]: 0   -0.2610351   -0.1259212   -0.2610353   -0.8844754   -0.2610355    0.227290dtype: float64</code></pre><p>这里用mean()函数对整体做了平均，而事实上我们大多数时候可能需要对各分组赋予不同的填充值，于是可以用以下方法实现填充：</p><p>假设你需要对不同的分组填充不同的值。一种方法是将数据分组，并使用apply和一个能够对各数据块调用fillna的函数即可。下面是一些有关美国几个州的示例数据，这些州又被分为东部和西部：</p><pre><code>In [95]: states = [&#39;Ohio&#39;, &#39;New York&#39;, &#39;Vermont&#39;, &#39;Florida&#39;,   ....:           &#39;Oregon&#39;, &#39;Nevada&#39;, &#39;California&#39;, &#39;Idaho&#39;]In [96]: group_key = [&#39;East&#39;] * 4 + [&#39;West&#39;] * 4In [97]: data = pd.Series(np.random.randn(8), index=states)In [98]: dataOut[98]: Ohio          0.922264New York     -2.153545Vermont      -0.365757Florida      -0.375842Oregon        0.329939Nevada        0.981994California    1.105913Idaho        -1.613716dtype: float64#将一些数据点设置为缺失值In [99]: data[[&#39;Vermont&#39;, &#39;Nevada&#39;, &#39;Idaho&#39;]] = np.nanIn [100]: dataOut[100]: Ohio          0.922264New York     -2.153545Vermont            NaNFlorida      -0.375842Oregon        0.329939Nevada             NaNCalifornia    1.105913Idaho              NaNdtype: float64In [101]: data.groupby(group_key).mean()Out[101]: East   -0.535707West    0.717926dtype: float64</code></pre><p>接下来可以用分组平均值去填充NA：</p><pre><code>In [102]: fill_mean = lambda g: g.fillna(g.mean())In [103]: data.groupby(group_key).apply(fill_mean)Out[103]: Ohio          0.922264New York     -2.153545Vermont      -0.535707Florida      -0.375842Oregon        0.329939Nevada        0.717926California    1.105913Idaho         0.717926dtype: float64</code></pre><p>可以看出，当apply函数作用与groupby时，<strong>他的对象就是groupby()中的分组键，或者更确切地说，是分组键分割开来的各个组</strong>，因此，apply中函数的对象也应该就考虑是一个dataframe或者series。</p><p>但这一点再直接应用到DataFrame时就有所不同，<strong>此时apply中函数的对象是dataframe的一列或者一行的每一个元素。</strong></p><p><img src="/2020/07/28/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0-dataframe-apply%E5%92%8Cgroupby-apply%E7%9A%84%E5%8C%BA%E5%88%AB/1.jpg" srcset="/img/loading.gif" alt></p><p><strong>可以看到majority函数的x的对象就是column age的每一个元素。</strong></p><p>参考：</p><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>参考了书上代码<a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>技术笔记</category>
      
      <category>python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>apply()函数</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[学习笔记]综合评价模型</title>
    <link href="/2020/07/27/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%BB%BC%E5%90%88%E8%AF%84%E4%BB%B7%E6%A8%A1%E5%9E%8B/"/>
    <url>/2020/07/27/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%BB%BC%E5%90%88%E8%AF%84%E4%BB%B7%E6%A8%A1%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<p>综合评价问题：综合考虑事物的多个指标所包含的信息，对各个备选决策方案优劣进行排序，最终选出最优方案。</p><p>主要步骤：（1）选择综合评价指标（不遗漏、不重复、尽可能独立）；（2）确定各参评方案的指标值，形成决策矩阵；（3）指标值预处理（目的：消除指标值在单位、数量级、方向性三个方面的差异）；（4）确定各项指标的权重系数（重要程度）；（5）对预处理后的指标值进行加权综合，给出各方案的综合得分，按照综合得分对各个参评方案进行优劣排序。</p><p>评价方法分类：（1）主观复权法：综合指数法、模糊综合评判法、层次分析法、功效系数法等。（2）客观赋权法：主成分分析法、因子分析法、熵权法、理想解法（TOPSIS法）等。</p><h2 id="层次分析法（AHP）"><a href="#层次分析法（AHP）" class="headerlink" title="层次分析法（AHP）"></a>层次分析法（AHP）</h2><p>假设有n个指标，我们虽然不知道他们的各自重要程度（权重），但知道它们的重要程度之比，则可以以这个比值建立一个成对比较矩阵A，根据矩阵获得各个指标的权重。</p><p>根据特征向量的定义，可以得出这个矩<strong>阵A具有特征值n和特征向量W = (W1,W2,W3,W4….Wn).T</strong>。</p><p><img src="/2020/07/27/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%BB%BC%E5%90%88%E8%AF%84%E4%BB%B7%E6%A8%A1%E5%9E%8B/1.jpg" srcset="/img/loading.gif" alt></p><p>并且有定理：1、A的秩为1，A的唯一非零特征值为n；2、A的任一列向量都是对应于特征值n 的特征向量。在此定理下，对任一列向量归一化后，就给出了这n个指标的权重的真实值。</p><p><strong>比值的确定就是主观的</strong>,Saaty等人提出1~9尺度——aij 取值1,2,… , 9及其互反数1,1/2, … , 1/9，因为心理学家认为成对比较的因素不宜超过9个。需要注意的是，对影响因素为负的指标，要提前做处理，不然性质不符，无法使用此方法。</p><p>性质1和性质2是较好满足的，但性质3这种传递性在主观下很难满足。但Saaty认为，我们在实际操作时不需要完全满足一致性，只要能通过<strong>一致性检验</strong>即可。</p><h3 id="一致性检验"><a href="#一致性检验" class="headerlink" title="一致性检验"></a>一致性检验</h3><p><img src="/2020/07/27/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%BB%BC%E5%90%88%E8%AF%84%E4%BB%B7%E6%A8%A1%E5%9E%8B/2.png" srcset="/img/loading.gif" alt></p><p>CI越大，不一致越严重。为衡量CI的大小，引入随机一致性指标RI——随机模拟得到aij, 形成A，计算CI即得RI。</p><p>令<strong>CR = CI/RI</strong>，一般认为当CR&lt;0.1时，通过一致性检验。</p><h2 id="熵权法"><a href="#熵权法" class="headerlink" title="熵权法"></a>熵权法</h2><p>熵权法是一种<strong>客观赋权法</strong>，基础是各项指标都已经量化好，利用指标值数据的离散程度来确定各项指标在综合评价中的权重，离散程度越大，该项指标权重越大。</p><p>在信息论中，熵是对不确定性的一种度量。不确定性越大，熵就越小。</p><h3 id="step1：数据预处理"><a href="#step1：数据预处理" class="headerlink" title="step1：数据预处理"></a>step1：数据预处理</h3><p><img src="/2020/07/27/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%BB%BC%E5%90%88%E8%AF%84%E4%BB%B7%E6%A8%A1%E5%9E%8B/2.jpg" srcset="/img/loading.gif" alt></p><h3 id="step2：数据归一化"><a href="#step2：数据归一化" class="headerlink" title="step2：数据归一化"></a>step2：数据归一化</h3><p>让各个指标数据的和为1，即Pi = Yi / （Y1+Y2+Y3+….+Yn）。</p><h3 id="step3：计算第j项指标的熵"><a href="#step3：计算第j项指标的熵" class="headerlink" title="step3：计算第j项指标的熵"></a>step3：计算第j项指标的熵</h3><p><img src="/2020/07/27/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%BB%BC%E5%90%88%E8%AF%84%E4%BB%B7%E6%A8%A1%E5%9E%8B/3.png" srcset="/img/loading.gif" alt></p><h3 id="step4：计算指标的离散程度并计算权重"><a href="#step4：计算指标的离散程度并计算权重" class="headerlink" title="step4：计算指标的离散程度并计算权重"></a>step4：计算指标的离散程度并计算权重</h3><p>令Dj = 1 - Ej（因为熵越大，不确定性越小），接下来再把各个指标的离散程度归一化处理。</p><h3 id="step6：计算结果并排序"><a href="#step6：计算结果并排序" class="headerlink" title="step6：计算结果并排序"></a>step6：计算结果并排序</h3><h2 id="理想点法"><a href="#理想点法" class="headerlink" title="理想点法"></a>理想点法</h2><p>理想点法是综合各个方案与理想的最优方案以及最差方案之间的距离，对各个方案的优劣进行排序，与最优方案越接近同时与最差方案距离越远的方案，综合得分越高。</p><h3 id="step1：数据的预处理"><a href="#step1：数据的预处理" class="headerlink" title="step1：数据的预处理"></a>step1：数据的预处理</h3><p>方法有很多，此处就不再赘述了。</p><h3 id="step2：确定各个指标的权重"><a href="#step2：确定各个指标的权重" class="headerlink" title="step2：确定各个指标的权重"></a>step2：确定各个指标的权重</h3><p>可以用所有用于确定指标权重的方法。</p><h3 id="step3：计算加权的指标值"><a href="#step3：计算加权的指标值" class="headerlink" title="step3：计算加权的指标值"></a>step3：计算加权的指标值</h3><h3 id="step4："><a href="#step4：" class="headerlink" title="step4："></a>step4：</h3>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>数学建模</category>
      
    </categories>
    
    
    <tags>
      
      <tag>综合评价模型</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[学习笔记]微分方程模型</title>
    <link href="/2020/07/27/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B%E6%A8%A1%E5%9E%8B/"/>
    <url>/2020/07/27/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B%E6%A8%A1%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<p><strong>微分方程模型的思想</strong>：假设我们要研究量x,y,z 与t的关系,微分方程模型的思想是从考察量x,y,z对t的导数(即x,y,z对t的变化率)入手，找出导数符合的规律，建立包含未知函数的导数(偏导数)的方程(方程组)，通过分析、求解微分方程（组）来获得x,y,z与t的函数关系。</p><p>以下是几个常见的根据微分方程构建的模型：</p><h2 id="人口增长模型"><a href="#人口增长模型" class="headerlink" title="人口增长模型"></a>人口增长模型</h2><h3 id="马尔萨斯的指数增长模型"><a href="#马尔萨斯的指数增长模型" class="headerlink" title="马尔萨斯的指数增长模型"></a>马尔萨斯的指数增长模型</h3><p>基本假设：单位时间内人口的增长率为常数r，即<img src="/2020/07/27/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B%E6%A8%A1%E5%9E%8B/1.png" srcset="/img/loading.gif" alt></p><p>x(t)可以用指数形式来表示，再通过求导即可得到每年的人口增长速度。这个模型有它的优点和缺陷：<strong>可用于短期人口增长预测</strong>（与19世纪以前欧洲一些地区人口统计数据吻合/适用于19世纪后迁往加拿大的欧洲移民后代），但<strong>不能预测较长期的人口增长过程</strong>（不符合19世纪后多数地区人口增长规律，人口增长率r逐渐下降）。</p><h3 id="阻滞增长模型（Logistic模型）"><a href="#阻滞增长模型（Logistic模型）" class="headerlink" title="阻滞增长模型（Logistic模型）"></a>阻滞增长模型（Logistic模型）</h3><p>基本思想：人口增长到一定程度时，由于资源、环境等约束，人口本身会对r产生影响，即r是x的减函数。最简单的函数是线性函数，因此令<strong>r（x） = r - sx， 其中s = r/Smax</strong>，在此条件下可以求得<img src="/2020/07/27/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B%E6%A8%A1%E5%9E%8B/2.png" srcset="/img/loading.gif" alt></p><p>两个未知参数r和Smax可以用以前的数据去拟合（ols）。</p><p>进一步改进则引入其他的非线性函数，并求解相关系数。</p><h3 id="传染病传播模型"><a href="#传染病传播模型" class="headerlink" title="传染病传播模型"></a>传染病传播模型</h3><p>比较科学的两个模型：SIS（传染病可治愈但无免疫性）和SIR（传染病可治愈且有免疫性）。</p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>数学建模</category>
      
    </categories>
    
    
    <tags>
      
      <tag>微分方程模型</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[技术笔记]jupyter不能通过浏览器自动打开</title>
    <link href="/2020/07/27/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0-jupyter%E4%B8%8D%E8%83%BD%E9%80%9A%E8%BF%87%E6%B5%8F%E8%A7%88%E5%99%A8%E8%87%AA%E5%8A%A8%E6%89%93%E5%BC%80/"/>
    <url>/2020/07/27/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0-jupyter%E4%B8%8D%E8%83%BD%E9%80%9A%E8%BF%87%E6%B5%8F%E8%A7%88%E5%99%A8%E8%87%AA%E5%8A%A8%E6%89%93%E5%BC%80/</url>
    
    <content type="html"><![CDATA[<p>这两天用win+R打开juypter的时候发现不能通过浏览器自动打开了，只能手动打开。之前我配置的默认浏览器是chrome，中间因为chrome版本太低Google帮我重装过一次，怀疑是重装过后的chrome被改了文件路径，从而导致打不开了，因此决定重新配置juypter的路径即可：</p><p>1、在cmd下执行<em>jupyter notebook —generate-config</em>，会提示该文件所在的目录，我的是C:\Users\Administrator.jupyter\jupyter_notebook_config.py。</p><p>2、进入该目录，用编辑器打开这个文件（我用的是Geany，应该txt编辑器也可以）。</p><p>3、用crtl+F找到<em>#c.NotebookApp.browser</em>，在其下方复制</p><pre><code>import webbrowserwebbrowser.register(&quot;chrome&quot;,None,webbrowser.GenericBrowser(r&quot;C:\Program Files (x86)\Google\Chrome\Application\chrome.exe&quot;))c.NotebookApp.browser = &#39;chrome&#39;</code></pre><p>我这里用的是chrome，其他浏览器同理，位置路径的确变了，因此替换了位置路径。如果不想改变字符串中的反斜杠\，则在字符串前加上r。</p><p>4、保存并运行，发现成功自动打开浏览器了。</p>]]></content>
    
    
    <categories>
      
      <category>技术笔记</category>
      
      <category>python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>jupyter notebook</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[学习笔记]差分方程模型</title>
    <link href="/2020/07/26/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%B7%AE%E5%88%86%E6%96%B9%E7%A8%8B%E6%A8%A1%E5%9E%8B/"/>
    <url>/2020/07/26/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%B7%AE%E5%88%86%E6%96%B9%E7%A8%8B%E6%A8%A1%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<p>差分方程，顾名思义，研究的是一组有规律序列相邻两个时间段间的规律，这种规律能够全部（部分）运用（使用迭代或递推）到一个总体，从而求解问题。</p><h2 id="一阶线性差分方程模型"><a href="#一阶线性差分方程模型" class="headerlink" title="一阶线性差分方程模型"></a>一阶线性差分方程模型</h2><p><strong><em>ΔAn = An+1 - An = f(An,其他因素)</em></strong> 这样一个方程可以被称为一阶差分方程模型，如果f(An,其他因素)是关于An的线性模式，则被称为一阶线性差分方程模型，即<img src="/2020/07/26/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%B7%AE%E5%88%86%E6%96%B9%E7%A8%8B%E6%A8%A1%E5%9E%8B/1.png" srcset="/img/loading.gif" alt></p><h3 id="一阶线性差分方程的解及其长期行为"><a href="#一阶线性差分方程的解及其长期行为" class="headerlink" title="一阶线性差分方程的解及其长期行为"></a>一阶线性差分方程的解及其长期行为</h3><p>很容易得到<img src="/2020/07/26/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%B7%AE%E5%88%86%E6%96%B9%E7%A8%8B%E6%A8%A1%E5%9E%8B/2.png" srcset="/img/loading.gif" alt></p><p>当n趋于无穷时，<img src="/2020/07/26/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%B7%AE%E5%88%86%E6%96%B9%E7%A8%8B%E6%A8%A1%E5%9E%8B/3.png" srcset="/img/loading.gif" alt><img src="/2020/07/26/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%B7%AE%E5%88%86%E6%96%B9%E7%A8%8B%E6%A8%A1%E5%9E%8B/4.jpg" srcset="/img/loading.gif" alt></p><h3 id="差分方程模型的平衡点"><a href="#差分方程模型的平衡点" class="headerlink" title="差分方程模型的平衡点"></a>差分方程模型的平衡点</h3><p>平衡点是指An = a, An+1 = a 的情况，如果长期行为等于平衡点，则称之为稳定的平衡点。</p><h2 id="一阶非线性差分方程模型"><a href="#一阶非线性差分方程模型" class="headerlink" title="一阶非线性差分方程模型"></a>一阶非线性差分方程模型</h2><p>我们一般通过变化的散点图，猜想出ΔAn变化的规律，即f(An,其他因素)的形式，再和OLS相结合来拟合关于ΔAn的曲线。当然，差分方程也只是解决拟合问题的一种方法，存在其他更加合适的方法时，也可以用其他方法解决。</p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>数学建模</category>
      
    </categories>
    
    
    <tags>
      
      <tag>差分方程模型</tag>
      
      <tag>动力系统模型</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[技术笔记]pandas中agg()与apply()的区别</title>
    <link href="/2020/07/19/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0-pandas%E4%B8%ADagg-%E4%B8%8Eapply-%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <url>/2020/07/19/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0-pandas%E4%B8%ADagg-%E4%B8%8Eapply-%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<p>对数据集进行分组并对各组应用一个函数（无论是聚合还是转换），通常是数据分析工作中的重要环节<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="源自‘python for data analysis’ chapter 10">[1]</span></a></sup>。<br><img src="/2020/07/19/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0-pandas%E4%B8%ADagg-%E4%B8%8Eapply-%E7%9A%84%E5%8C%BA%E5%88%AB/1.png" srcset="/img/loading.gif" alt></p><p>这张表就阐述了整一个GroupBy的机制。一般来说，Split部分用groupby()完成，但apply部分可以用apply,agg以及其他一些特定的函数完成（如count，mean，sum等）。</p><p>在<em>‘python for data analysis’</em>一书中并没有很明确地指出这两者的区别，只是说apply比agg更具有普适性，但对应的运行速度也会偏慢（好比在agg中执行自建函数总要比执行已经规划好的优化函数要慢一样）。</p><p>看了网上很多资料，感觉agg与apply的区别主要是，agg只能对数组运算并产生标量值，而apply除此之外还可以返回一个pandas对象，这是agg做不到的，就比如想要对一个数组进行排序操作时，就只能用apply而不能用agg。</p><p>引用：</p><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>源自<em>‘python for data analysis’ chapter 10</em><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>技术笔记</category>
      
      <category>python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据聚合和分组运算</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[学习笔记]插值与拟合</title>
    <link href="/2020/07/17/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%8F%92%E5%80%BC%E4%B8%8E%E6%8B%9F%E5%90%88/"/>
    <url>/2020/07/17/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%8F%92%E5%80%BC%E4%B8%8E%E6%8B%9F%E5%90%88/</url>
    
    <content type="html"><![CDATA[<p>插值的一般思路：根据已知数据点构造一个一般的函数，该函数对现有数据有较好的拟合效果，再用这个函数进行插值预测。构造函数的方法是一个重点（回归的<em>OLS、FSLS、GLS、WLS、Probit、Logit</em>等都是计量中评估的函数方法）。插值一般用来进行填补数据集，但不用做数据预测。 </p><h2 id="多项式插值"><a href="#多项式插值" class="headerlink" title="多项式插值"></a>多项式插值</h2><p>通过一个构造一个多项式函数去插值。原因：1.多项式函数比较简单2.<strong><em>Weierstrass</em>一致逼近定理</strong>：给定一个任意小的e，对于一段连续曲线，一定存在一个多项式，两者在定义域内的插值的绝对值小于任何给定的e。</p><p>那么，<strong>如何确定多项式的形式</strong>呢？在多项插值法中的要求是，要使估计函数在第i个观测值处的值f(xi)=实际观测值。</p><p>其优点是：1.可以确定<strong>唯一</strong>的一个估计函数（根据范德蒙行列式的结论，证明略）；2.在已知<strong>观测值附近，该函数的近似效果是非常好</strong>的（显然，对于一个连续函数，就是有这样的能力，高等数学里都有学到，这也是OLS这种总体误差最小方法所不具备的优点）。</p><p>并且，如果题目提供n+1个观测值，就可以据此列出一个n次多项式（因为n次多项式有包括截距在内有n+1个未知数，需要n+1个条件）。但这样也存在问题，当次数多，数据大时，<strong>容易出现<em>Runge</em>现象</strong>，即高次项数对数据很敏感，微小的扰动都会造成巨大的变化。因此，具有下列改进的方法：</p><h3 id="Lagrange插值法"><a href="#Lagrange插值法" class="headerlink" title="Lagrange插值法"></a><em>Lagrange</em>插值法</h3><p><img src="/2020/07/17/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%8F%92%E5%80%BC%E4%B8%8E%E6%8B%9F%E5%90%88/1.png" srcset="/img/loading.gif" alt></p><p>其中，<img src="/2020/07/17/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%8F%92%E5%80%BC%E4%B8%8E%E6%8B%9F%E5%90%88/2.png" srcset="/img/loading.gif" alt></p><h3 id="Newton插值法"><a href="#Newton插值法" class="headerlink" title="Newton插值法"></a><em>Newton</em>插值法</h3><p><img src="/2020/07/17/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%8F%92%E5%80%BC%E4%B8%8E%E6%8B%9F%E5%90%88/3.png" srcset="/img/loading.gif" alt></p><p>其中，<img src="/2020/07/17/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%8F%92%E5%80%BC%E4%B8%8E%E6%8B%9F%E5%90%88/4.png" srcset="/img/loading.gif" alt><img src="/2020/07/17/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%8F%92%E5%80%BC%E4%B8%8E%E6%8B%9F%E5%90%88/5.png" srcset="/img/loading.gif" alt></p><h3 id="分段插值法"><a href="#分段插值法" class="headerlink" title="分段插值法"></a>分段插值法</h3><p>分段插值法的建立主要是基于上述两种方法在观测点增多时，次数增加，仍会出现<em>Runge</em>现象，因此分段求函似乎会更好。</p><p>比较常见的分段求函就是两个数据点间的线性插值或者三个数据点间的抛物线插值。</p><h3 id="样条插值法"><a href="#样条插值法" class="headerlink" title="样条插值法"></a>样条插值法</h3><p>分段插值虽然避免了<em>Runge</em>现象，但也使曲线很不平滑。因此，用样条插值法改善这一现象。</p><p>三次样条插值：在相邻的两个结点间用一条三次多项式曲线来近似并插值。</p><p>现在的问题是，两个结点之间就需要构造一个三次函数意味着所有结点的三次函数需要4n个条件才能求解，而n+1个观测值只提供了n+1个条件，还缺少3n-1个条件。因此要保证在插值结点处满足衔接条件：<img src="/2020/07/17/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%8F%92%E5%80%BC%E4%B8%8E%E6%8B%9F%E5%90%88/6.png" srcset="/img/loading.gif" alt></p><p>这又提供了3n-3个条件，还缺2个条件需要自己定义。</p><ol><li>方法一：定义最初和最末两个结点处的斜率（实际意义是最初和最末的该变量增长速度如何）。</li><li>方法二：定义最初和最末两个结点的二阶导数，一般令其=0（几何意义是斜率为0&lt;—&gt;曲率为0）.</li><li>方法三：<strong>周期边界条件</strong>，即最初和最末两个结点函数值相同，斜率相同。这说明该段观测值会重复出现，这个数据集具有周期性。</li><li>方法四：根据具体问题具体分析，自己添加即可。</li></ol><h3 id="最邻近插值法"><a href="#最邻近插值法" class="headerlink" title="最邻近插值法"></a>最邻近插值法</h3><p>要估计的值最邻近哪个观测值结点，就将那个观测值作为估计值，是一种简单而不准确的估计方法。</p><h2 id="二维插值"><a href="#二维插值" class="headerlink" title="二维插值"></a>二维插值</h2><p>由单自变量变为双自变量问题。结点类型一般分为网格型结点和散乱型结点，根据不同的结点类型<em>Matlab</em>会选择不同的方法。</p><p>插值方法：</p><h3 id="最邻近插值法-1"><a href="#最邻近插值法-1" class="headerlink" title="最邻近插值法"></a>最邻近插值法</h3><p>同多项式插值法中的最邻近插值法原理。</p><h3 id="分片线性插值"><a href="#分片线性插值" class="headerlink" title="分片线性插值"></a>分片线性插值</h3><p>三角形区域连成一整块即可，具体求值用<em>Matlab</em>。</p><h3 id="双线性插值"><a href="#双线性插值" class="headerlink" title="双线性插值"></a>双线性插值</h3><p>对于四个结点构成的网格，构造一个z=(ax+b)(cy+d)，四个未知数用四个网格结点求解，得到一个双线性函数来估计该网格内某点的值。</p><h2 id="曲线拟合"><a href="#曲线拟合" class="headerlink" title="曲线拟合"></a>曲线拟合</h2><p>在前面我们已经给出了一种方法：多项式插值。这种方法要求用来近似未知函数f的n次插值多项式准确无误地经过已知的n+1个结点。然而当结点数据是由某种实验或者计算方法得出的，就难免带有误差，要求多项式严格经过这些结点，无形中就会将误差保留下来，而且如果每一个结点都有误差的话，由于误差累积的效应，也会导致整体的近似效果较差。</p><p>这促使我们寻求一种新的方法近似未知函数，这一方法并不要求用来近似的函数严格通过已知结点，而只要求在结点处误差，按某一标准最小。为了计算方便，通常就采用误差的平方和最小作为度量误差的标准，即<strong>最小二乘原则**</strong>（OLS）**。</p><p>具体计算在<em>Matlab</em>中用<em>polyfit</em>相关命令完成多项式拟合求解。其他类型的曲线则用其他类型的函数解决。</p><h3 id="一个变形：加权最小二乘法-WLS"><a href="#一个变形：加权最小二乘法-WLS" class="headerlink" title="一个变形：加权最小二乘法(WLS)"></a>一个变形：加权最小二乘法(WLS)</h3><p>使用的原因：在不同的观测值点，数据的偏差很不一样（异方差性？在计量经济学中用来解决异方差问题）。</p><h3 id="拟合效果的评价"><a href="#拟合效果的评价" class="headerlink" title="拟合效果的评价"></a>拟合效果的评价</h3><p>最大相对误差/平均相对误差/拟合优度….</p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>数学建模</category>
      
    </categories>
    
    
    <tags>
      
      <tag>插值</tag>
      
      <tag>拟合</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[学习笔记]数学规划模型深入</title>
    <link href="/2020/07/16/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%95%B0%E5%AD%A6%E8%A7%84%E5%88%92%E6%A8%A1%E5%9E%8B%E6%B7%B1%E5%85%A5/"/>
    <url>/2020/07/16/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%95%B0%E5%AD%A6%E8%A7%84%E5%88%92%E6%A8%A1%E5%9E%8B%E6%B7%B1%E5%85%A5/</url>
    
    <content type="html"><![CDATA[<h2 id="一个例题"><a href="#一个例题" class="headerlink" title="一个例题"></a>一个例题</h2><p><img src="/2020/07/16/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%95%B0%E5%AD%A6%E8%A7%84%E5%88%92%E6%A8%A1%E5%9E%8B%E6%B7%B1%E5%85%A5/1.jpg" srcset="/img/loading.gif" alt></p><h3 id="第一小问"><a href="#第一小问" class="headerlink" title="第一小问"></a>第一小问</h3><p>第一小问比较好解决，典型的线性规划问题，列举出所有的切割模式（共7种）后，将第i种模式切割的原料钢管根数作为决策变量即可，唯一需要注意的是，约束条件不能是三种钢管个数恰好=(50,20,15)，而应该是&gt;=(50,20,15)，否则可能会造成无解。</p><h3 id="第二小问"><a href="#第二小问" class="headerlink" title="第二小问"></a>第二小问</h3><p>第二小问增加了一种需求和一个约束条件：5米10根；切割模式不超过3种。用枚举法确定合理切割模式较为复杂，因此不如将使用哪种模式也加入决策变量，让lingo自己解决这个问题。当然这需要一个人为的合理度量，此处选择为每根余料不超过3米，即如下附加约束条件：<br><img src="/2020/07/16/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%95%B0%E5%AD%A6%E8%A7%84%E5%88%92%E6%A8%A1%E5%9E%8B%E6%B7%B1%E5%85%A5/2.jpg" srcset="/img/loading.gif" alt></p><p>原本的线性约束条件也因此变成了未知量*未知量的非线性约束组合：<br><img src="/2020/07/16/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%95%B0%E5%AD%A6%E8%A7%84%E5%88%92%E6%A8%A1%E5%9E%8B%E6%B7%B1%E5%85%A5/3.jpg" srcset="/img/loading.gif" alt></p><p>还可以通过人为增加决策变量的约束减少计算量。</p><h2 id="一些小结"><a href="#一些小结" class="headerlink" title="一些小结"></a>一些小结</h2><h3 id="可能的解"><a href="#可能的解" class="headerlink" title="可能的解"></a>可能的解</h3><ol><li>全局最优解</li><li>局部最优解</li><li>中断解</li></ol><h3 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h3><ol><li>按照有无约束</li></ol><p>（1）约束优化（constrained optimization）</p><p>（2）无约束优化（unconstrained opt）</p><ol><li>按照决策变量x的分量取值</li></ol><p>（1）连续优化/数学规划（continuous opt / mathematical programming）</p><p>（2）离散优化/组合优化（discrete opt / combinatorial opt ）</p><ol><li>按照目标函数的个数</li></ol><p>单目标规划与多目标规划</p><ol><li>按照参数或者决策变量是否具有不确定性</li></ol><p>确定性规划与不确定性规划（如随机规划、模糊规划等）</p><ol><li>按照目标函数f，约束条件g、h是否连续可微</li></ol><p>光滑优化与非光滑优化</p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>数学建模</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数学规划模型</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[学习笔记]数学规划模型初识</title>
    <link href="/2020/07/16/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%95%B0%E5%AD%A6%E8%A7%84%E5%88%92%E6%A8%A1%E5%9E%8B%E5%88%9D%E8%AF%86/"/>
    <url>/2020/07/16/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%95%B0%E5%AD%A6%E8%A7%84%E5%88%92%E6%A8%A1%E5%9E%8B%E5%88%9D%E8%AF%86/</url>
    
    <content type="html"><![CDATA[<h2 id="数学规划模型的三要素"><a href="#数学规划模型的三要素" class="headerlink" title="数学规划模型的三要素"></a>数学规划模型的三要素</h2><ol><li>决策变量</li><li>目标函数</li><li>约束条件</li></ol><h2 id="0-1变量的运算特点"><a href="#0-1变量的运算特点" class="headerlink" title="0-1变量的运算特点"></a>0-1变量的运算特点</h2><p>在0-1变量中，<img src="/2020/07/16/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%95%B0%E5%AD%A6%E8%A7%84%E5%88%92%E6%A8%A1%E5%9E%8B%E5%88%9D%E8%AF%86/1.png" srcset="/img/loading.gif" alt>，两者互为充要条件，而在一般情形下，前者是后者的充分不必要条件。</p><p>0-1变量还可以描述约束条件（if-else）关系，<img src="/2020/07/16/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%95%B0%E5%AD%A6%E8%A7%84%E5%88%92%E6%A8%A1%E5%9E%8B%E5%88%9D%E8%AF%86/2.jpg" srcset="/img/loading.gif" alt>，如图例题所示。</p><h2 id="多目标规划模型的处理方法"><a href="#多目标规划模型的处理方法" class="headerlink" title="多目标规划模型的处理方法"></a>多目标规划模型的处理方法</h2><p>多目标规划下，往往这n个目标<strong>相互矛盾</strong>，其解决思路是转变多目标规划为单目标规划。</p><h3 id="方法一：按照目标的重要性分步求解"><a href="#方法一：按照目标的重要性分步求解" class="headerlink" title="方法一：按照目标的重要性分步求解"></a>方法一：按照目标的重要性分步求解</h3><p>如在选课策略模型中，任务要求选修课程最少，且学分尽量多，应学习哪些课程。首先认为选修课程最少为第一目标，在此基础上加入课程总门数的约束，再进行求解。</p><h4 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h4><p>如果有更多个目标，那么很难对目标的重要性进行排序。<br>即使排出顺序，也需要求解很多个单目标规划。<br>当第一个目标对应的单目标规划问题的最优解唯一时，后面的单目标规划丧失意义，并且对于整数规划，Lingo无法告诉我们最优解是否唯一。</p><h3 id="方法二：将多目标加权求和变为单目标"><a href="#方法二：将多目标加权求和变为单目标" class="headerlink" title="方法二：将多目标加权求和变为单目标"></a>方法二：将多目标加权求和变为单目标</h3><p>显然加权系数取决于该目标的重要性。</p><h4 id="缺点：-1"><a href="#缺点：-1" class="headerlink" title="缺点："></a>缺点：</h4><p>由于多个目标之间单位、数量级不一致，导致综合目标没有实际意义。<br>权重系数难以确定。</p><h4 id="注意点："><a href="#注意点：" class="headerlink" title="注意点："></a>注意点：</h4><p>在多个目标的方向不一致（max/min）时，如果综合目标是max，则需要将子目标是min的取相反数再综合。<br>权重还可以为函数，模型会变复杂，但稳健性提升了。</p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>数学建模</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数学规划模型</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[技术笔记]pandas中的逻辑运算符</title>
    <link href="/2020/07/14/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0-pandas%E4%B8%AD%E7%9A%84%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6/"/>
    <url>/2020/07/14/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0-pandas%E4%B8%AD%E7%9A%84%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6/</url>
    
    <content type="html"><![CDATA[<p>首先需要说明的是，在pandas中进行逻辑运算时，其运算符不再是<strong>and</strong>;<strong>or</strong>;<strong>not</strong>，转而变成了相对应的<strong>&amp;</strong>，<strong>|</strong>，<strong>～</strong>，<sup><a href="#fn_1" id="reffn_1">1</a></sup>如下列代码:</p><pre><code>In [129]: s = pd.Series(range(-3, 4)) In [132]: s[(s &lt; -1) | (s &gt; 0.5)] Out[132]:             0   -3            1   -2            4    1            5    2            6    3            dtype: int64 </code></pre><p>其原因是什么？查阅了网上的一些<a href="https://www.imooc.com/wenda/detail/567532" target="_blank" rel="noopener">资料</a>发现，是因为当我们使用and，or，not等运算符时，python自动将运算符两边的式子转换为bool类型再进行比较，而在pandas的Series、DataFrame以及numpy的array上，是没有bool值的，所以在元素级的操作上使用&amp;、|、～代替。</p><p>（题外话：当然更具体的我也不是很清楚，这有待后续学习了《流畅的python》后再验证，一想到github上就有电子版，我还傻乎乎花了一百多买了个新书我就很心痛）</p><p>值得注意的是，其<strong>元素符优先级</strong>也发生了改变，在pandas中，这类逻辑运算符优先级很高，因此运算符两侧最好时刻都<strong>加上括号</strong>，防止不必要的错误。比如：</p><pre><code>In[23]: army[(army.deaths &gt; 500) | (army.deaths &lt; 50)]Out[23]: regiment    company    deaths    battles    size    veterans    readiness    armored    desertersorigin                                    Arizona    Nighthawks    1st    523    5    1045    1    1    1    4Texas    Nighthawks    2nd    25    2    1099    62    3    1    31Florida    Nighthawks    2nd    616    2    1400    26    3    1    2Maine    Dragoons    1st    43    4    1592    73    2    0    3Alaska    Dragoons    2nd    523    8    987    949    2    0    24Louisana    Scouts    2nd    37    8    1099    63    2    1    2Georgia    Scouts    2nd    35    9    1523    345    3    1    3</code></pre><p>是正确的，而army[army.deaths &gt; 500 | army.deaths &lt; 50]则会报错：<em>ValueError: The truth value of a Series is ambiguous. Use a.empty, a.bool(), a.item(), a.any() or a.all().</em></p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><sup><a href="#fn_1" id="reffn_1">1</a></sup>： 来源：<a href="https://blog.csdn.net/claroja/article/details/65661826" target="_blank" rel="noopener">https://blog.csdn.net/claroja/article/details/65661826</a> </p>]]></content>
    
    
    <categories>
      
      <category>技术笔记</category>
      
      <category>python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>逻辑运算符</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[学习笔记]模型的灵敏度分析和稳健性分析方法</title>
    <link href="/2020/07/13/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0-%E6%A8%A1%E5%9E%8B%E7%9A%84%E7%81%B5%E6%95%8F%E5%BA%A6%E5%88%86%E6%9E%90%E5%92%8C%E7%A8%B3%E5%81%A5%E6%80%A7%E5%88%86%E6%9E%90%E6%96%B9%E6%B3%95/"/>
    <url>/2020/07/13/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0-%E6%A8%A1%E5%9E%8B%E7%9A%84%E7%81%B5%E6%95%8F%E5%BA%A6%E5%88%86%E6%9E%90%E5%92%8C%E7%A8%B3%E5%81%A5%E6%80%A7%E5%88%86%E6%9E%90%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>在完成做出假设，用符号表示有关量，列出数学表达式，求解得到答案后，还需要对所得到的答案进行<em>灵敏度分析</em>和<em>稳健性分析</em>。本文旨在复习所学到的检验分析方法。</p><p><strong><em>灵敏度分析</em></strong>的意义在于，所得数据为测量值，与实际值可能存在差异，如果模型的输出对模型的输入很敏感，可能导致模型的偏误被放大，因此要对模型进行灵敏度分析。这让我联想到伍德里奇《计量经济学》第九章对于数据问题的再讨论，即解释变量的测量误差在CEV假定下，会对有误差的估计量造成衰减偏误，其他解释变量同样受到影响。</p><p>而<strong><em>稳健性分析</em></strong>在旨在放松假定，对更一般化的情况进行检验，毕竟假设往往线性、简单、理想化，可能与实际结果不符合。</p><h2 id="灵敏度分析"><a href="#灵敏度分析" class="headerlink" title="灵敏度分析"></a>灵敏度分析</h2><h3 id="方法一：数值法"><a href="#方法一：数值法" class="headerlink" title="方法一：数值法"></a>方法一：数值法</h3><p>对可能存在的误差大小进行估计，将观测值根据误差范围进行调整再输入模型，观察观测值的改变量大小对输出值改变量大小的影响（当然都是相对指标，一般以百分比衡量）。在输入时多参数的情况下，一般有两种思路：（1）只改变一个参数，保持其他参数不变，用来检验最不容易确定的参数；（2）改变若干参数，考察一组参数的稳定性，因为可能参数之间本就存在协同性。</p><h3 id="方法二：解析法"><a href="#方法二：解析法" class="headerlink" title="方法二：解析法"></a>方法二：解析法</h3><p>数值法是直接带入数据进行计算，而解析法则是通过对公式的分析，从数学模型上得到一个相对变化率，再带入数值检验，<strong>更加精确</strong>。如单输入-单输出情形下，变化率的求解就很简单。但其也存在其显而易见的缺点：在多输入-多输出情况下，<strong>获得精确的解析式非常困难</strong>；<strong>很多问题是离散的</strong>。</p><h2 id="稳健性分析"><a href="#稳健性分析" class="headerlink" title="稳健性分析"></a>稳健性分析</h2><p>在很多实际问题中，为了简单起见，我们往往会做出许多线性化的假设，同时也会将某些与时间有关的变量假设成与时间无关的常量，这使得得到的数学模型有很大的局限性。</p><p>对已有模型进行强健性分析是指将模型中线性化的假设改为更一般的非线性情形，同时将常量改为变量，然后重新分析、建模、求解。</p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>数学建模</category>
      
    </categories>
    
    
    <tags>
      
      <tag>灵敏度分析</tag>
      
      <tag>稳健性分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2020/07/12/hello-world/"/>
    <url>/2020/07/12/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="hljs bash">$ hexo new <span class="hljs-string">"My New Post"</span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="hljs bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="hljs bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="hljs bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
